---
# required metadata

title: Observable data actions
description: Observable data actions are used to track the status of the data action as it is running, this is helpful if you need to run logic or render UI in response to the current status of your data action.
author: SamJarawan
manager: JeffBl
ms.date: 08/30/2019
ms.topic: article
ms.prod: 
ms.service: Dynamics365Operations
ms.technology: 

# optional metadata

# ms.search.form: 
audience: Developer
# ms.devlang: 
ms.reviewer: josaw
ms.search.scope: Retail, Core, Operations
# ms.tgt_pltfrm: 
ms.custom: 
ms.assetid: 
ms.search.region: Global
# ms.search.industry: 
ms.author: SamJar
ms.search.validFrom: 2019-08-30
ms.dyn365.ops.version: 

---
# Observable data actions

Observable data actions are used to track the status of the data action as it is running, this is helpful if you need to run logic or render UI in response to the current status of your data action.  Observable data actions use a special promise-like class `AsyncResult` which adds "observer" functionality to a standard promise.

Below example shows you how to take advantage of an `AsyncResult`.  This data action example waits three seconds before it returns a string.

```typescript
// test-action.ts
/**
 * Test action method for TestAsync action
 * @param input The action input
 * @param context The action context
 */
const testAction = async (input: TestAsyncActionInput, context: IActionContext): Promise<string> => {
    await new Promise(resolve => {
        setTimeout(
            () => {
                resolve();
        },  3000);
    });

    // Flag-based error scenario
    if (input.shouldError) {
        throw new Error('Oops');
    }

    return 'foo';
};

/**
 * Test Action Input
 */
export class TestAsyncActionInput implements IActionInput {
    public shouldError: Boolean = false;

    constructor(shouldError?: Boolean) {
        this.shouldError = shouldError || this.shouldError;
    }

    public getCacheKey = () => `test`;
    public getCacheObjectType = () => 'test';
    public dataCacheType = (): Msdyn365.CacheType => 'none';
}

/**
 * Test createInput method for TestAsync Action
 */
const createInput = () => {
    return new TestAsyncActionInput();
};
```

This data action simulates an outgoing API call, along with a flag which can set to allow a failure simulation. In certain scenarios we may want to create a module that can give us updates about the status of this data action. This would not be possible with a normal data action.

## Creating an observable data action
To create an observable data action use the data action creation utility method `createObservableDataAction`:

```typescript
export default createObservableDataAction({
    input: createInput,
    action: <IAction<string>>testAction
});
```

This new method `createObservableDataAction` is equivalent to `createDataAction` except it returns an `IObservableAction` instead of an `IAction`, which returns an `AsyncResult` instead of a `Promise` like a standard `IAction`. This gives us access to additional data when the data action is consumed including the `status` and `error` of the data action. 

A mock can be created to test the data action:

```tsx
// test-module.tsx
import { observer } from 'mobx-react';
import * as React from 'react';

import { IAsyncTestModuleData } from './async-test-module.data';
import { IAsyncTestModuleProps } from './async-test-module.props.autogenerated';

import testAction, { TestAsyncActionInput } from './actions/async-test-action';

/**
 * TestModule Component
 * @extends {React.PureComponent<IAsyncTestModuleProps<IAsyncTestModuleData>>}
 */
@observer
class AsyncTestModule extends React.PureComponent<IAsyncTestModuleProps<IAsyncTestModuleData>> {
    constructor(props: IAsyncTestModuleProps<IAsyncTestModuleData>) {
        super(props);
    }

    public render(): JSX.Element {
        return (
            <div className='row'>
                <div className='col'>
                    <h1>Status: { this.props.data.testResult.status }</h1>
                    <h1>Result: { this.props.data.testResult.result }</h1>
                    { this.props.data.testResult.error &&
                        <h1>Error: { this.props.data.testResult.error.message }</h1>
                    }
                    <button
                        // tslint:disable:jsx-no-lambda
                        // tslint:disable-next-line:react-this-binding-issue
                        onClick={(e) => this._clientCall(e)}
                    > Run on client
                    </button>
                    <button
                        // tslint:disable:jsx-no-lambda
                        // tslint:disable-next-line:react-this-binding-issue
                        onClick={(e) => this._clientCall(e, true)}
                    > Error on client
                    </button>
                </div>
            </div>
        );
    }
}

export default AsyncTestModule;
```

Below is a sample module definition, which registers the sample observable data action created above:

```json
// test-module.definition.json
{
    "$type": "contentModule",
    "friendlyName": "test-module",
    "name": "test-module",
    "description": "Module for testing observable data actions",
    "categories": ["test-module"],
    "tags": ["samples"],
    "module": {
        "view": "./test-module",
        "dataActions": {
            "testResult":{
                "path": "./actions/test-action",
                "runOn": "client"
            }
        }
    }
}
```

When creating the data.ts file, we have to make sure that all observableDataAction's are wrapped with AsyncResult. This ensures the correct typings when writing a module:

```typescript
// test-module.data.ts
import { AsyncResult } from '@msdyn365-commerce/retail-proxy';

export interface IAsyncTestModuleData {
    testResult: AsyncResult<string>;
}
```

Now that the data action is wrapped with `AsyncResult` we can see during module development that we have access to new properties including `testResult.status` which will contains the current state of our data action ('Success', 'Loading', or 'Failed') and `testResult.result` which will contain the actual data returned by our action if our action succeeds.

Initially, our module renders and shows that the data action is in a loading state, because of the `setTimeout` that we are using to simulate an API call in progress. Once the `setTimeout` completes and the action successfully returns data, our module automatically rerenders, this time showing the `SUCCESS` state along with the data we returned from the action, available within the `result` property.

In addition, if we have the data action throw an error the module updates accordingly on the page, instead of our result property getting populated, the `error` property of our `AsyncResult` has been filled in because our action was not able to execute.

By taking advantage of the `status`, `result` and `error` properties provided by observable data actions, handling complicated scenarios in a module such as displaying a loading screen while an API call runs, or providing a user contextual error messages in response to a failed data actions, becomes very simple.
