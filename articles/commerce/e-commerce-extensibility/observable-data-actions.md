---
# required metadata

title: Create an observable data action
description: This topic describes how to create an observable data action in Dynamics 365 Commerce.
author: samjarawan
manager: annbe
ms.date: 10/01/2019
ms.topic: article
ms.prod: 
ms.service: dynamics-ax-retail
ms.technology: 

# optional metadata

# ms.search.form: 
audience: Application user
# ms.devlang: 
ms.reviewer: v-chgri
ms.search.scope: Retail, Core, Operations
# ms.tgt_pltfrm: 
ms.custom: 
ms.assetid: 
ms.search.region: Global
# ms.search.industry: 
ms.author: samjar
ms.search.validFrom: 2019-10-31
ms.dyn365.ops.version: Release 10.0.5

---
# Create an observable data action

[!include [banner](../includes/preview-banner.md)]
[!include [banner](../includes/banner.md)]

This topic describes how to create an observable data action in Dynamics 365 Commerce.

## Overview

Observable data actions are used to track the status of a data action as it is running. This is helpful if you need to run logic or render UI in response to the current status of a data action. Observable data actions use a special promise-like class `AsyncResult` which adds "observer" functionality to a standard promise.

The following example shows how to take advantage of an `AsyncResult`. This data action waits three seconds before it returns a string.

```typescript
// test-action.ts
/**
 * Test action method for TestAsync action
 * @param input The action input
 * @param context The action context
 */
const testAction = async (input: TestAsyncActionInput, context: IActionContext): Promise<string> => {
    await new Promise(resolve => {
        setTimeout(
            () => {
                resolve();
        },  3000);
    });

    // Flag-based error scenario
    if (input.shouldError) {
        throw new Error('Oops');
    }

    return 'foo';
};

/**
 * Test Action Input
 */
export class TestAsyncActionInput implements IActionInput {
    public shouldError: Boolean = false;

    constructor(shouldError?: Boolean) {
        this.shouldError = shouldError || this.shouldError;
    }

    public getCacheKey = () => `test`;
    public getCacheObjectType = () => 'test';
    public dataCacheType = (): Msdyn365.CacheType => 'none';
}

/**
 * Test createInput method for TestAsync Action
 */
const createInput = () => {
    return new TestAsyncActionInput();
};
```

The example data action simulates an outgoing API call, and also includes a flag which can be set to allow a failure simulation. In certain scenarios you may want to create a module that can send updates about the status of a data action, which would not be possible with a normal data action.

## Create your observable data action
To create your observable data action, use the data action creation utility method `createObservableDataAction`:

```typescript
export default createObservableDataAction({
    input: createInput,
    action: <IAction<string>>testAction
});
```

This new method `createObservableDataAction` is equivalent to `createDataAction` except that it returns an `IObservableAction` instead of an `IAction`, which returns an `AsyncResult` instead of a `Promise` like a standard `IAction`. This gives us access to additional data when the data action is consumed including the `status` and `error` of the data action. 

A mock can be created to test the data action:

```tsx
// test-module.tsx
import { observer } from 'mobx-react';
import * as React from 'react';

import { IAsyncTestModuleData } from './async-test-module.data';
import { IAsyncTestModuleProps } from './async-test-module.props.autogenerated';

import testAction, { TestAsyncActionInput } from './actions/async-test-action';

/**
 * TestModule Component
 * @extends {React.PureComponent<IAsyncTestModuleProps<IAsyncTestModuleData>>}
 */
@observer
class AsyncTestModule extends React.PureComponent<IAsyncTestModuleProps<IAsyncTestModuleData>> {
    constructor(props: IAsyncTestModuleProps<IAsyncTestModuleData>) {
        super(props);
    }

    public render(): JSX.Element {
        return (
            <div className='row'>
                <div className='col'>
                    <h1>Status: { this.props.data.testResult.status }</h1>
                    <h1>Result: { this.props.data.testResult.result }</h1>
                    { this.props.data.testResult.error &&
                        <h1>Error: { this.props.data.testResult.error.message }</h1>
                    }
                    <button
                        // tslint:disable:jsx-no-lambda
                        // tslint:disable-next-line:react-this-binding-issue
                        onClick={(e) => this._clientCall(e)}
                    > Run on client
                    </button>
                    <button
                        // tslint:disable:jsx-no-lambda
                        // tslint:disable-next-line:react-this-binding-issue
                        onClick={(e) => this._clientCall(e, true)}
                    > Error on client
                    </button>
                </div>
            </div>
        );
    }
}

export default AsyncTestModule;
```

The following example shows a sample module definition, which registers the sample observable data action created above.

```json
// test-module.definition.json
{
    "$type": "contentModule",
    "friendlyName": "test-module",
    "name": "test-module",
    "description": "Module for testing observable data actions",
    "categories": ["test-module"],
    "tags": ["samples"],
    "module": {
        "view": "./test-module",
        "dataActions": {
            "testResult":{
                "path": "./actions/test-action",
                "runOn": "client"
            }
        }
    }
}
```

When creating the data.ts file, we have to make sure that all observableDataAction's are wrapped with AsyncResult. This ensures the correct typings when writing a module:

```typescript
// test-module.data.ts
import { AsyncResult } from '@msdyn365-commerce/retail-proxy';

export interface IAsyncTestModuleData {
    testResult: AsyncResult<string>;
}
```

Now that the data action is wrapped with `AsyncResult`, we can see during module development that we have access to new properties. These properties include `testResult.status`, which will contains the current state of our data action ('Success', 'Loading', or 'Failed'), and `testResult.result`, which will contain the actual data returned by the action if it succeeds.

Initially, the module renders and shows that the data action is in a loading state because the `setTimeout` used simulates an API call in progress. Once the `setTimeout` completes and the action successfully returns data, the module automatically renders again, this time showing the `SUCCESS` state along with the data returned from the action, which is available within the `result` property.

If the data action throws an error, the module updates accordingly on the page instead of the `result` property getting populated. The `error` property of the `AsyncResult` is filled in because the action was unable to execute.

By taking advantage of the `status`, `result`, and `error` properties provided by observable data actions, handling complicated scenarios in a module becomes very simple. Examples of these types of complicated scenarios include displaying a loading screen while an API call runs, or providing a user contextual error messages in response to a failed data action.
