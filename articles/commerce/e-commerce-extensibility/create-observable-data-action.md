---
# required metadata

title: Create an observable data action
description: This topic describes how to create an observable data action in Microsoft Dynamics 365 Commerce.
author: samjarawan
manager: annbe
ms.date: 10/01/2019
ms.topic: article
ms.prod: 
ms.service: dynamics-ax-retail
ms.technology: 

# optional metadata

# ms.search.form: 
audience: Application user
# ms.devlang: 
ms.reviewer: v-chgri
ms.search.scope: Retail, Core, Operations
# ms.tgt_pltfrm: 
ms.custom: 
ms.assetid: 
ms.search.region: Global
# ms.search.industry: 
ms.author: samjar
ms.search.validFrom: 2019-10-31
ms.dyn365.ops.version: Release 10.0.5

---
# Create an observable data action

[!include [banner](../includes/preview-banner.md)]
[!include [banner](../includes/banner.md)]

This topic describes how to create an observable data action in Microsoft Dynamics 365 Commerce.

## Overview

Observable data actions are used to track the status of a data action as it's running. This capability is helpful if you must run logic or render a user interface (UI) in response to the current status of a data action. Observable data actions use a special promise-like class that is named **AsyncResult**. This class adds "observer" functionality to a standard promise.

The following example shows how to take advantage of an **AsyncResult** class. This data action waits three seconds before it returns a string.

```typescript
// test-action.ts
/**
 * Test action method for TestAsync action
 * @param input The action input
 * @param context The action context
 */
const testAction = async (input: TestAsyncActionInput, context: IActionContext): Promise<string> => {
    await new Promise(resolve => {
        setTimeout(
            () => {
                resolve();
        },  3000);
    });

    // Flag-based error scenario
    if (input.shouldError) {
        throw new Error('Oops');
    }
    return 'foo';
};

/**
 * Test Action Input
 */
export class TestAsyncActionInput implements IActionInput {
    public shouldError: Boolean = false;
    constructor(shouldError?: Boolean) {
        this.shouldError = shouldError || this.shouldError;
    }
    public getCacheKey = () => `test`;
    public getCacheObjectType = () => 'test';
    public dataCacheType = (): Msdyn365.CacheType => 'none';
}

/**
 * Test createInput method for TestAsync Action
 */
const createInput = () => {
    return new TestAsyncActionInput();
};
```

In this example, the data action simulates an outgoing application programming interface (API) call. It also includes a flag that can be set to allow a failure simulation. In some scenarios, you might want to create a module that can send updates about the status of a data action. You can't use a regular data action for that purpose.

## Create the observable data action

To create the observable data action, use the new **createObservableDataAction** utility method for data action creation.

```typescript
export default createObservableDataAction({
    input: createInput,
    action: <IAction<string>>testAction
});
```

The **createObservableDataAction** method is equivalent to the **createDataAction** method, but it returns an **IObservableAction** instead of an **IAction**, which returns an **AsyncResult** class instead of the **Promise** that a standard **IAction** returns. Therefore, you have access to additional data when the data action is consumed. This data includes the **status** and **error** properties of the data action. 

A mock can be created to test the data action, as shown in the following example.

```tsx
// test-module.tsx
import { observer } from 'mobx-react';
import * as React from 'react';
import { IAsyncTestModuleData } from './async-test-module.data';
import { IAsyncTestModuleProps } from './async-test-module.props.autogenerated';
import testAction, { TestAsyncActionInput } from './actions/async-test-action';

/**
 * TestModule Component
 * @extends {React.PureComponent<IAsyncTestModuleProps<IAsyncTestModuleData>>}
 */
@observer
class AsyncTestModule extends React.PureComponent<IAsyncTestModuleProps<IAsyncTestModuleData>> {
    constructor(props: IAsyncTestModuleProps<IAsyncTestModuleData>) {
        super(props);
    }
    public render(): JSX.Element {
        return (
            <div className='row'>
                <div className='col'>
                    <h1>Status: { this.props.data.testResult.status }</h1>
                    <h1>Result: { this.props.data.testResult.result }</h1>
                    { this.props.data.testResult.error &&
                        <h1>Error: { this.props.data.testResult.error.message }</h1>
                    }
                    <button
                        // tslint:disable:jsx-no-lambda
                        // tslint:disable-next-line:react-this-binding-issue
                        onClick={(e) => this._clientCall(e)}
                    > Run on client
                    </button>
                    <button
                        // tslint:disable:jsx-no-lambda
                        // tslint:disable-next-line:react-this-binding-issue
                        onClick={(e) => this._clientCall(e, true)}
                    > Error on client
                    </button>
                </div>
            </div>
        );
    }
}
export default AsyncTestModule;
```

The following example shows a sample module definition that registers the sample observable data action that was created earlier.

```json
// test-module.definition.json
{
    "$type": "contentModule",
    "friendlyName": "test-module",
    "name": "test-module",
    "description": "Module for testing observable data actions",
    "categories": ["test-module"],
    "tags": ["samples"],
    "module": {
        "view": "./test-module",
        "dataActions": {
            "testResult":{
                "path": "./actions/test-action",
                "runOn": "client"
            }
        }
    }
}
```

When you create the data.ts file, you must make sure that every **observableDataAction** is wrapped by an **AsyncResult** class. In this way, you help guarantee the correct typings when a module is written.

```typescript
// test-module.data.ts
import { AsyncResult } from '@msdyn365-commerce/retail-proxy';
export interface IAsyncTestModuleData {
    testResult: AsyncResult<string>;
}
```

Now that the data action is wrapped by an **AsyncResult** class, you will notice that you have access to new properties during module development. These properties include **testResult.status**, which contains the current state of the data action (**'Success'**, **'Loading'**, or **'Failed'**), and **testResult.result**, which contains the actual data that is returned by the action if it succeeds.

When the module is first rendered, it shows that the data action is in a loading state, because the **setTimeout** that is used simulates an API call that is in progress. After the **setTimeout** is completed, and the action successfully returns data, the module is automatically rendered again. This time, it shows the **SUCCESS** state together with the data that is returned from the action and available in the **result** property.

If the data action throws an error, the **result** property isn't filled in. Instead, the module is updated accordingly on the page. The **error** property of the **AsyncResult** class is filled in, because the action wasn't able to run.

By taking advantage of the **status**, **result**, and **error** properties that are provided by observable data actions, you can easily handle complicated scenarios in a module. Examples of complicated scenarios include showing a loading screen while an API call runs and providing contextual error messages in response to a failed data action.
