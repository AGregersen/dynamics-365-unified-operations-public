---
# required metadata

title: Share state across modules
description: This topic covers sharing state across multiple modules by using data actions in Dynamics 365 Commerce.
author: samjarawan
manager: annbe
ms.date: 10/01/2019
ms.topic: article
ms.prod: 
ms.service: dynamics-ax-retail
ms.technology: 

# optional metadata

# ms.search.form: 
audience: Application user
# ms.devlang: 
ms.reviewer: v-chgri
ms.search.scope: Retail, Core, Operations
# ms.tgt_pltfrm: 
ms.custom: 
ms.assetid: 
ms.search.region: Global
# ms.search.industry: 
ms.author: samjar
ms.search.validFrom: 2019-10-31
ms.dyn365.ops.version: Release 10.0.5

---
# Share state across modules

This topic covers sharing state across multiple modules by using data actions in Dynamics 365 Commerce.

## Overview

Data actions fill the important role of state management in situations where you need to share state across multiple modules on the same page.

## Examples

Let's start with an example that has two modules that share basic interaction. One module will have a button (`sample-button`) and the other module will display a message when that button is clicked (`sample-message`). We'll start with a data action that returns an object containing the number of times the button has been clicked, which looks like the following.

```typescript
// sample-state.ts
import { CacheType, createObservableDataAction, IAction, IActionContext, IActionInput, IAny, ICreateActionContext, IGeneric } from '@msdyn365-commerce/core';

export interface ISampleState {
    clickCount: number;
}

/**
 * SampleState - action input
 */
export class SampleStateInput implements IActionInput {
    public getCacheKey = () => `SampleState`;
    public getCacheObjectType = () => 'SampleState';
    public dataCacheType = (): CacheType => 'request';
}

/**
 * SampleState - action
 */
export async function sampleStateAction(input: SampleStateInput, ctx: IActionContext): Promise<ISampleState> {
    return { clickCount: 0 };
}

/**
 * SampleState - create new input for create action
 */
const createInput = (inputData: ICreateActionContext<IGeneric<IAny>>): IActionInput => {
    return new SampleStateInput();
};

/**
 * SampleState - create action
 */
export default createObservableDataAction<ISampleState>({
    action: <IAction<ISampleState>>sampleStateAction,
    input: createInput
});
```

This data action has no implementation in its current state, all it does is create a place in the cache where we are storing an object. Observing this object can be very useful for helping modules talk to each other. To get modules access to this object, we must ensure that the modules register the data action we have created as a page load data action.

```json
// sample-button.definition.json
{
  "$type": "contentModule",
  "friendlyName": "Sample Button",
  "name": "sample-button",
  "description": "Sample Button",
  "categories": ["sample-button"],
  "tags": ["samples"],
  "module": {
      "view": "./sample-button",
      "dataActions": {
          "sampleState": {
              "path": "../../actions/sample-state/sample-state"
          }
      }
  }
}
```json
// sample-message.definition.json
{
  "$type": "contentModule",
  "friendlyName": "Sample Message",
  "name": "sample-message",
  "description": "Sample Message",
  "categories": ["sample-message"],
  "tags": ["samples"],
  "module": {
      "view": "./sample-message",
      "dataActions": {
          "sampleState": {
              "path": "../../actions/sample-state/sample-state"
          }
      }
  }
}
```

Both of the modules are now registered to the data action, which means they are both observing the same object in the application state. The only thing left to do is update the application state when the `sample-button` module has a user click event. Then all modules observing the app state should automatically update accordingly. Below is an example of a `sample-message` module.

```typescript
// sample-message.data.ts
import { AsyncResult } from '@msdyn365-commerce/retail-proxy';
import { ISampleState } from '../../actions/sample-state/sample-state';

export interface ISampleMessageData {
    sampleState: AsyncResult<ISampleState>;
}
```

```tsx
// sample-message.tsx
import * as React from 'react';
import { ISampleMessageData } from './sample-message.data';
import { ISampleMessageProps } from './sample-message.props.autogenerated';

/**
 * SampleMessage Module used for showcasing cross-module communication
 * @extends {React.Component<ISampleMessageProps<ISampleMessageData>>}
 */
export default class SampleMessage extends React.Component<ISampleMessageProps<ISampleMessageData>> {
    constructor(props: ISampleMessageProps<ISampleMessageData>) {
        super(props);
    }

    public render(): JSX.Element {
        if(this.props.data.sampleState.result) {
            return (<h3>The Button has been clicked {this.props.data.sampleState.result.clickCount} times.</h3>);
        }

        return (<h3>Error: No Sample State Detected</h3>);
    }
}
```

The `sample-message` module is very straightforward, all it does is ask for the `ISampleState` using a page load data action and render a simple message based on the data returned. Because the application state is internally powered by [MobX](https://mobx.js.org/), this module can automatically react when the data it is observing changes. 

Next let's look at `sample-button`, which will update the application state based on a user click event:

```typescript
// sample-button.data.ts
import { AsyncResult } from '@msdyn365-commerce/retail-proxy';
import { ISampleState } from '../../actions/sample-state/sample-state';

export interface ISampleButtonData {
    sampleState: AsyncResult<ISampleState>;
}
```

```tsx
// sample-button.tsx
import * as React from 'react';
import { ISampleButtonData } from './sample-button.data';
import { ISampleButtonProps } from './sample-button.props.autogenerated';

import { SampleStateInput } from '../../actions/sample-state/sample-state';

/**
 * SampleButton component used for showcasing cross-module communication
 * @extends {React.Component<ISampleButtonProps<ISampleButtonData>>}
 */
export default class SampleButton extends React.Component<ISampleButtonProps<ISampleButtonData>> {
    constructor(props: ISampleButtonProps<ISampleButtonData>) {
        super(props);
        this._onClick.bind(this);
    }

    public render(): JSX.Element {
        return (
            <button onClick={this._onClick}>
                Click Me!
            </button>
        );
    }

    // OnClick Handler should update application state
    private _onClick = (e: React.MouseEvent): void => {
        if (this.props.data.sampleState.result) {
            // This will directly update our application state, which should trigger all modules observing the state to update
            this.props.context.actionContext.update(new SampleStateInput(), { clickCount: this.props.data.sampleState.result.clickCount + 1 });
        }
    }
}
```

Above you can see that the onClick handler makes a call to `actionContext.update()`, which lets us directly mutate the application state. When the state is mutated, MobX takes over and rerenders all modules which are observing the piece of state that includes the `sample-message` module.
