---
# required metadata

title: Cross module communication
description: Data actions fill the important role of state management in situations where you need to share state across multiple modules on the same page.
author: SamJarawan
manager: JeffBl
ms.date: 08/30/2019
ms.topic: article
ms.prod: 
ms.service: Dynamics365Operations
ms.technology: 

# optional metadata

# ms.search.form: 
audience: Developer
# ms.devlang: 
ms.reviewer: josaw
ms.search.scope: Retail, Core, Operations
# ms.tgt_pltfrm: 
ms.custom: 
ms.assetid: 
ms.search.region: Global
# ms.search.industry: 
ms.author: SamJar
ms.search.validFrom: 2019-08-30
ms.dyn365.ops.version: 

---
# Sharing State Across Modules

Data actions fill the important role of state management in situations where you need to share state across multiple modules on the same page.

Lets take an example with two modules that share basic interaction. One module will have a button (`sample-button`) and the other module will display a message when that button is clicked(`sample-message`). We'll start with a data action that returns an object containing the number of times the button has been clicked, which looks like the following:

```typescript
// sample-state.ts
import { CacheType, createObservableDataAction, IAction, IActionContext, IActionInput, IAny, ICreateActionContext, IGeneric } from '@msdyn365-commerce/core';

export interface ISampleState {
    clickCount: number;
}

/**
 * SampleState - action input
 */
export class SampleStateInput implements IActionInput {
    public getCacheKey = () => `SampleState`;
    public getCacheObjectType = () => 'SampleState';
    public dataCacheType = (): CacheType => 'request';
}

/**
 * SampleState - action
 */
export async function sampleStateAction(input: SampleStateInput, ctx: IActionContext): Promise<ISampleState> {
    return { clickCount: 0 };
}

/**
 * SampleState - create new input for create action
 */
const createInput = (inputData: ICreateActionContext<IGeneric<IAny>>): IActionInput => {
    return new SampleStateInput();
};

/**
 * SampleState - create action
 */
export default createObservableDataAction<ISampleState>({
    action: <IAction<ISampleState>>sampleStateAction,
    input: createInput
});
```

This action has no implementation in its current state, all it does in create a place in the cache where we are storing an object. But this can be very useful for helping modules talk to each other, by observing this object. To get modules acceess to this object we just need to make sure these modules register this data action we have created as a Page Load data action:

```json
// sample-button.definition.json
{
  "$type": "contentModule",
  "friendlyName": "Sample Button",
  "name": "sample-button",
  "description": "Sample Button",
  "categories": ["sample-button"],
  "tags": ["samples"],
  "module": {
      "view": "./sample-button",
      "dataActions": {
          "sampleState": {
              "path": "../../actions/sample-state/sample-state"
          }
      }
  }
}
```json
// sample-message.definition.json
{
  "$type": "contentModule",
  "friendlyName": "Sample Message",
  "name": "sample-message",
  "description": "Sample Message",
  "categories": ["sample-message"],
  "tags": ["samples"],
  "module": {
      "view": "./sample-message",
      "dataActions": {
          "sampleState": {
              "path": "../../actions/sample-state/sample-state"
          }
      }
  }
}
```

Both of our modules are now registered to this data action, which means they are both observing the same object in our application state. The only thing left to do is update the application state when our `sample-button` module has its button pressed, and then all modules observering the app state should automatically update accordingly. Below is a `sample-message` module:

```typescript
// sample-message.data.ts
import { AsyncResult } from '@msdyn365-commerce/retail-proxy';
import { ISampleState } from '../../actions/sample-state/sample-state';

export interface ISampleMessageData {
    sampleState: AsyncResult<ISampleState>;
}
```

```tsx
// sample-message.tsx
import * as React from 'react';
import { ISampleMessageData } from './sample-message.data';
import { ISampleMessageProps } from './sample-message.props.autogenerated';

/**
 * SampleMessage Module used for showcasing cross-module communication
 * @extends {React.Component<ISampleMessageProps<ISampleMessageData>>}
 */
export default class SampleMessage extends React.Component<ISampleMessageProps<ISampleMessageData>> {
    constructor(props: ISampleMessageProps<ISampleMessageData>) {
        super(props);
    }

    public render(): JSX.Element {
        if(this.props.data.sampleState.result) {
            return (<h3>The Button has been clicked {this.props.data.sampleState.result.clickCount} times.</h3>);
        }

        return (<h3>Error: No Sample State Detected</h3>);
    }
}
```

This module is very straightforward, all it does is ask for our `ISampleState` via a Page Load data action and then render a simple message based off the data returned. Because our application state is internally powered by [MobX](https://mobx.js.org/), this module can automatically react when the data it is observing changes! Now let's look at `sample-button` which will update our application state based on a user click event:

```typescript
// sample-button.data.ts
import { AsyncResult } from '@msdyn365-commerce/retail-proxy';
import { ISampleState } from '../../actions/sample-state/sample-state';

export interface ISampleButtonData {
    sampleState: AsyncResult<ISampleState>;
}
```

```tsx
// sample-button.tsx
import * as React from 'react';
import { ISampleButtonData } from './sample-button.data';
import { ISampleButtonProps } from './sample-button.props.autogenerated';

import { SampleStateInput } from '../../actions/sample-state/sample-state';

/**
 * SampleButton component used for showcasing cross-module communication
 * @extends {React.Component<ISampleButtonProps<ISampleButtonData>>}
 */
export default class SampleButton extends React.Component<ISampleButtonProps<ISampleButtonData>> {
    constructor(props: ISampleButtonProps<ISampleButtonData>) {
        super(props);
        this._onClick.bind(this);
    }

    public render(): JSX.Element {
        return (
            <button onClick={this._onClick}>
                Click Me!
            </button>
        );
    }

    // OnClick Handler should update application state
    private _onClick = (e: React.MouseEvent): void => {
        if (this.props.data.sampleState.result) {
            // This will directly update our application state, which should trigger all modules observing the state to update
            this.props.context.actionContext.update(new SampleStateInput(), { clickCount: this.props.data.sampleState.result.clickCount + 1 });
        }
    }
}
```

Above you can see the onClick handler makes a call to `actionContext.update()`, which let's us directly mutate our application state. When the state is mutated, MobX takes over and re-renders all modules which are observing that piece of state which includes our `sample-message` module.
